# План миграции на использование классов vectors.py

## Цель

Переключить работу фронтенда и хранилища на использование классов из `backend/domain/vectors.py` вместо прямого использования JSON-словарей. Это обеспечит:
- Типобезопасность
- Инкапсуляцию данных
- Единообразие форматов (storage vs frontend)
- Валидацию данных
- Упрощение поддержки кода

## Текущее состояние

### Backend
- `GeometryService` работает напрямую с `Dict[str, Any]` (JSON)
- Методы `load_current_geometry()`, `save_geometry()` возвращают/принимают словари
- Методы `add_point()`, `update_point()`, `add_segment()`, `update_segment()` создают словари вручную
- Версионирование работает с JSON-файлами

### API Routes
- `backend/api/geometry/routes.py` принимает JSON из запросов
- Возвращает JSON напрямую из `GeometryService`
- Нет конвертации между форматами storage и frontend

### Frontend
- Отправляет JSON через `fetch()` API
- Получает JSON и использует напрямую
- Ожидает формат с `points`, `segments`, `geometryLayers`

## Целевое состояние

### Backend
- `GeometryService` работает с объектами классов (`Point`, `Segment`, `Geometry`, `Parcel`, `GeometryLayer`, `Site`)
- При загрузке из файла: JSON → объекты классов
- При сохранении в файл: объекты классов → JSON (storage format)
- Методы работают с объектами, а не словарями

### API Routes
- При получении запроса: JSON (frontend format) → объекты классов
- При отправке ответа: объекты классов → JSON (frontend format)
- Используют `to_frontend_json()` и `from_frontend_json()`

### Frontend
- Без изменений (продолжает работать с JSON)
- Получает данные в формате frontend через `to_frontend_json()`

## План миграции

### Этап 1: Подготовка и анализ

#### 1.1 Анализ текущих форматов данных
- [ ] Документировать текущий формат storage JSON
- [ ] Документировать текущий формат frontend JSON
- [ ] Сравнить с форматами в `vectors.py` (`to_storage_json()` vs `to_frontend_json()`)
- [ ] Выявить несоответствия и несовместимости

#### 1.2 Создание тестовых данных
- [ ] Создать тестовые JSON файлы для миграции
- [ ] Проверить конвертацию существующих данных через классы
- [ ] Выявить edge cases

#### 1.3 Обновление классов vectors.py (если нужно)
- [ ] Проверить соответствие форматов в `to_storage_json()` и `to_frontend_json()`
- [ ] Добавить недостающие поля или методы
- [ ] Исправить несоответствия форматов

### Этап 2: Рефакторинг GeometryService

#### 2.1 Создание вспомогательных методов конвертации
- [ ] Добавить метод `_load_site_from_json()` в `GeometryService`
- [ ] Добавить метод `_save_site_to_json()` в `GeometryService`
- [ ] Добавить метод `_create_empty_site()` для создания пустого Site
- [ ] Протестировать конвертацию на тестовых данных

#### 2.2 Рефакторинг методов загрузки
- [ ] Изменить `load_current_geometry()`:
  - Загружать JSON из файла
  - Конвертировать в объект `Site` через `Site.from_storage_json()`
  - Возвращать объект `Site` (или конвертировать в frontend JSON для API)
- [ ] Обновить обработку пустого состояния (создавать пустой `Site`)

#### 2.3 Рефакторинг методов сохранения
- [ ] Изменить `save_geometry()`:
  - Принимать объект `Site` или JSON (для обратной совместимости)
  - Если JSON - конвертировать в `Site`
  - Сохранять через `site.to_storage_json()`
  - Версионирование работает с JSON (как сейчас)

#### 2.4 Рефакторинг методов работы с точками
- [ ] Изменить `add_point()`:
  - Создавать объект `Point` через конструктор
  - Добавлять в `Site` (нужно определить структуру Site для session-based геометрии)
  - Сохранять через `save_geometry()`
- [ ] Изменить `update_point()`:
  - Загружать `Site`
  - Находить `Point` по ID
  - Обновлять свойства через setter'ы
  - Сохранять через `save_geometry()`

#### 2.5 Рефакторинг методов работы с сегментами
- [ ] Изменить `add_segment()`:
  - Создавать объект `LineSegment` или `ArcSegment`
  - Добавлять в `Geometry` → `Parcel` → `GeometryLayer` → `Site`
  - Сохранять через `save_geometry()`
- [ ] Изменить `update_segment()`:
  - Загружать `Site`
  - Находить сегмент через иерархию (Layer → Parcel → Geometry → Segment)
  - Обновлять свойства через setter'ы
  - Сохранять через `save_geometry()`

#### 2.6 Рефакторинг метода undo
- [ ] Изменить `undo()`:
  - Загружать предыдущую версию как JSON
  - Конвертировать в `Site` через `Site.from_storage_json()`
  - Сохранять через `save_geometry()`

### Этап 3: Обновление API Routes

#### 3.1 Обновление GET endpoints
- [ ] `GET /api/geometry/<session_id>`:
  - Получать `Site` из `GeometryService.load_current_geometry()`
  - Конвертировать в frontend JSON через `site.to_frontend_json()`
  - Возвращать JSON

#### 3.2 Обновление POST/PUT endpoints для точек
- [ ] `POST /api/geometry/<session_id>/point`:
  - Принимать JSON из запроса
  - Создавать `Point` через `Point.from_frontend_json()` или конструктор
  - Вызывать `geometry_service.add_point()` с объектом `Point`
  - Возвращать frontend JSON через `point.to_frontend_json()`
- [ ] `PUT /api/geometry/<session_id>/point/<point_id>`:
  - Принимать JSON из запроса
  - Вызывать `geometry_service.update_point()` с параметрами
  - Возвращать обновленный объект в frontend JSON

#### 3.3 Обновление POST/PUT endpoints для сегментов
- [ ] `POST /api/geometry/<session_id>/segment`:
  - Принимать JSON из запроса
  - Определять тип сегмента (line/arc)
  - Создавать `LineSegment` или `ArcSegment`
  - Вызывать `geometry_service.add_segment()` с объектом
  - Возвращать frontend JSON
- [ ] `PUT /api/geometry/<session_id>/segment/<segment_id>`:
  - Принимать JSON из запроса
  - Вызывать `geometry_service.update_segment()` с параметрами
  - Возвращать обновленный объект в frontend JSON

#### 3.4 Обновление POST endpoint для сохранения
- [ ] `POST /api/geometry/<session_id>/save`:
  - Принимать JSON из запроса (frontend format)
  - Конвертировать в `Site` через `Site.from_frontend_json()`
  - Вызывать `geometry_service.save_geometry()` с объектом `Site`
  - Возвращать результат

#### 3.5 Обновление POST endpoint для undo
- [ ] `POST /api/geometry/<session_id>/undo`:
  - Вызывать `geometry_service.undo()`
  - Получать `Site`
  - Конвертировать в frontend JSON через `site.to_frontend_json()`
  - Возвращать JSON

### Этап 4: Адаптация структуры данных

#### 4.1 Определение структуры Site для session-based геометрии
**Проблема**: Текущая структура использует `points` и `segments` на верхнем уровне, а `Site` использует иерархию `geometryLayers` → `parcels` → `geometry` → `segments`.

**Решения**:
- **Вариант A**: Создать упрощенную структуру для session-based геометрии
  - Создать класс `SessionGeometry` как обертку над `Site`
  - Хранить `points` и `segments` в отдельном слое или в атрибутах
- **Вариант B**: Адаптировать текущую структуру к иерархии Site
  - Создавать дефолтный `GeometryLayer` для session
  - Хранить `points` в отдельном списке или в атрибутах Site
  - Хранить `segments` в `Geometry` → `Parcel` → `GeometryLayer`

**Рекомендация**: Вариант B - использовать полную иерархию, но создать helper-методы для упрощения работы с `points` и `segments`.

#### 4.2 Создание helper-методов в GeometryService
- [ ] `get_points(site: Site) -> List[Point]` - получить все точки из Site
- [ ] `add_point_to_site(site: Site, point: Point) -> None` - добавить точку в Site
- [ ] `get_segments(site: Site) -> List[Segment]` - получить все сегменты из Site
- [ ] `add_segment_to_site(site: Site, segment: Segment) -> None` - добавить сегмент в Site

#### 4.3 Миграция существующих данных
- [ ] Создать скрипт миграции для конвертации старых JSON в новый формат
- [ ] Протестировать миграцию на реальных данных
- [ ] Обеспечить обратную совместимость (поддержка старого формата при загрузке)

### Этап 5: Тестирование

#### 5.1 Unit тесты
- [ ] Тесты конвертации JSON → объекты → JSON
- [ ] Тесты методов `GeometryService` с объектами
- [ ] Тесты валидации данных через классы

#### 5.2 Integration тесты
- [ ] Тесты API endpoints с полным циклом (запрос → объект → сохранение → загрузка → ответ)
- [ ] Тесты версионирования с объектами
- [ ] Тесты undo/redo с объектами

#### 5.3 Ручное тестирование
- [ ] Создание точек через UI
- [ ] Редактирование точек через UI
- [ ] Создание сегментов через UI
- [ ] Редактирование сегментов через UI
- [ ] Undo/redo операций
- [ ] Загрузка существующих данных

### Этап 6: Обновление документации

#### 6.1 Обновление API документации
- [ ] Документировать форматы JSON для frontend
- [ ] Документировать форматы JSON для storage
- [ ] Обновить примеры запросов/ответов

#### 6.2 Обновление developer documentation
- [ ] Документировать использование классов `vectors.py`
- [ ] Добавить примеры работы с `GeometryService`
- [ ] Обновить архитектурную документацию

### Этап 7: Оптимизация и рефакторинг

#### 7.1 Оптимизация производительности
- [ ] Проверить накладные расходы на конвертацию
- [ ] Оптимизировать частые операции
- [ ] Добавить кэширование при необходимости

#### 7.2 Финальный рефакторинг
- [ ] Удалить неиспользуемый код
- [ ] Улучшить обработку ошибок
- [ ] Добавить логирование

## Риски и митигация

### Риск 1: Несовместимость форматов
**Митигация**: 
- Тщательное тестирование конвертации
- Поддержка обоих форматов на этапе миграции
- Скрипт миграции данных

### Риск 2: Потеря данных при миграции
**Митигация**:
- Резервное копирование перед миграцией
- Тестирование на копиях данных
- Валидация после миграции

### Риск 3: Производительность
**Митигация**:
- Профилирование до и после
- Оптимизация критических путей
- Кэширование при необходимости

### Риск 4: Регрессии в функциональности
**Митигация**:
- Полное покрытие тестами
- Постепенная миграция (по одному методу)
- Откат изменений при проблемах

## Критерии готовности

Миграция считается завершенной, когда:
- [ ] Все методы `GeometryService` работают с объектами классов
- [ ] Все API endpoints конвертируют между JSON и объектами
- [ ] Все существующие тесты проходят
- [ ] Новые тесты покрывают работу с классами
- [ ] Frontend работает без изменений
- [ ] Существующие данные загружаются корректно
- [ ] Версионирование работает корректно
- [ ] Undo/redo работает корректно
- [ ] Документация обновлена

## Порядок выполнения

Рекомендуемый порядок:
1. Этап 1 (подготовка)
2. Этап 4.1-4.2 (определение структуры и helper-методы)
3. Этап 2 (рефакторинг GeometryService)
4. Этап 3 (обновление API routes)
5. Этап 5 (тестирование)
6. Этап 4.3 (миграция данных, если нужно)
7. Этап 6 (документация)
8. Этап 7 (оптимизация)

## Примечания

- Миграция должна быть постепенной, с возможностью отката
- Каждый этап должен быть протестирован перед переходом к следующему
- Важно сохранить обратную совместимость на время миграции
- После завершения миграции можно удалить старый код работы с JSON

